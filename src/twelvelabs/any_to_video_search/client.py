# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.any_to_video_search_any_to_video_search_request_search_options_item import (
    AnyToVideoSearchAnyToVideoSearchRequestSearchOptionsItem,
)
from .. import core
from .types.any_to_video_search_any_to_video_search_request_group_by import (
    AnyToVideoSearchAnyToVideoSearchRequestGroupBy,
)
from ..types.threshold_search import ThresholdSearch
from .types.any_to_video_search_any_to_video_search_request_sort_option import (
    AnyToVideoSearchAnyToVideoSearchRequestSortOption,
)
from ..types.conversation_option_any_to_video import ConversationOptionAnyToVideo
from ..core.request_options import RequestOptions
from .types.any_to_video_search_any_to_video_search_response import (
    AnyToVideoSearchAnyToVideoSearchResponse,
)
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..errors.too_many_requests_error import TooManyRequestsError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.any_to_video_search_any_to_video_retrieve_specific_page_response import (
    AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse,
)
from ..core.jsonable_encoder import jsonable_encoder
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AnyToVideoSearchClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def any_to_video_search(
        self,
        *,
        index_id: str,
        search_options: typing.List[
            AnyToVideoSearchAnyToVideoSearchRequestSearchOptionsItem
        ],
        query_media_type: typing.Optional[typing.Literal["image"]] = OMIT,
        query_media_url: typing.Optional[str] = OMIT,
        query_media_file: typing.Optional[core.File] = OMIT,
        query_text: typing.Optional[str] = OMIT,
        adjust_confidence_level: typing.Optional[float] = OMIT,
        group_by: typing.Optional[
            AnyToVideoSearchAnyToVideoSearchRequestGroupBy
        ] = OMIT,
        threshold: typing.Optional[ThresholdSearch] = OMIT,
        sort_option: typing.Optional[
            AnyToVideoSearchAnyToVideoSearchRequestSortOption
        ] = OMIT,
        operator: typing.Optional[str] = OMIT,
        conversation_option: typing.Optional[ConversationOptionAnyToVideo] = OMIT,
        page_limit: typing.Optional[int] = OMIT,
        filter: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnyToVideoSearchAnyToVideoSearchResponse:
        """
        Use this endpoint to search for relevant matches in an index using text or various media formats.
        
        To perform a search using a text query:
        
        - Use the `query_text` parameter to specify your query.
        
        To perform a search using a media query:
        
        - Set the `query_media_type` parameter to the corresponding media type (example: `image`).
        - Specify either one of the following parameters:
          - The `query_media_url` parameter with the publicly accessible URL of your media file.
          - The `query_media_file` parameter with a local media file.
            If both `query_media_url` and `query_media_file` are specified in the same request, `query_media_url` takes precedence.
        
        Before using a media file as a query, ensure that the file meets the [prerequisites](/docs/single-queries-prerequisites).
        
        **NOTE**: This endpoint is rate-limited. For details, see the [Rate limits](/docs/rate-limits) page.
        
        Parameters
        ----------
        index_id : str
            The unique identifier of the index to search.
            
        
        search_options : typing.List[AnyToVideoSearchAnyToVideoSearchRequestSearchOptionsItem]
            Specifies the [sources of information](/docs/search-options) the platform uses when performing a search. You must include the `search_options` parameter separately for each desired source of information.
            
            **NOTES:**
            - The search options you specify must be a subset of the [engine options](/docs/engine-options) used when you created the index.
            - You can specify multiple search options in conjunction with the `operator` parameter described below to broaden or narrow your search.
            
            Example:
            To search using both visual and audio cues, include this parameter twice in the request as shown below:
            ```JSON
            --form search_options=visual \
            --form search_options=conversation \
            ```
            
        
        query_media_type : typing.Optional[typing.Literal["image"]]
            The type of media you wish to use. This parameter is required for media queries. For example, to perform an image-based search, set this parameter to `image`.
            
        
        query_media_url : typing.Optional[str]
            The publicly accessible URL of the media file you wish to use. This parameter is required for media queries if `query_media_file` is not provided.
            
        
        query_media_file : typing.Optional[core.File]
            See core.File for more documentation
        
        query_text : typing.Optional[str]
            The text query to search for. This parameter is required for text queries. Note that the platform supports full natural language-based search.
            
        
        adjust_confidence_level : typing.Optional[float]
            This parameter specifies the strictness of the thresholds for assigning the high, medium, or low confidence levels to search results. If you use a lower value, the thresholds become more relaxed, and more search results will be classified as having high, medium, or low confidence levels. You can use this parameter to include a broader range of potentially relevant video clips, even if some results might be less precise.
            
            **Min**: 0
            **Max**: 1
            **Default:** 0.5
            
        
        group_by : typing.Optional[AnyToVideoSearchAnyToVideoSearchRequestGroupBy]
            Use this parameter to group or ungroup items in a response. It can take one of the following values:
            - `video`:  The platform will group the matching video clips in the response by video.
            - `clip`: The matching video clips in the response will not be grouped.
            
            **Default:** `clip`
            
        
        threshold : typing.Optional[ThresholdSearch]
        
        sort_option : typing.Optional[AnyToVideoSearchAnyToVideoSearchRequestSortOption]
            Use this parameter to specify the sort order for the response.
            
            When performing a search, the platform determines the level of confidence that each video clip matches your search terms. By default, the search results are sorted on the level of confidence in descending order.
            
            If you set this parameter to `score` and `group_by` is set to `video`, the platform will determine the maximum value of the `score` field for each video and sort the videos in the response by the maximum value of this field. For each video, the matching video clips will be sorted by the level of confidence.
            
            If you set this parameter to `clip_count` and `group_by` is set to `video`, the platform will sort the videos in the response by the number of clips. For each video, the matching video clips will be sorted by the level of confidence. You can use `clip_count` only when the matching video clips are sorted by video.
            
            
            **Default:** `score`
            
        
        operator : typing.Optional[str]
            When you perform a search specifying multiple [sources of information](/docs/search-options), you can use the this parameter to broaden or narrow your search.
            
              The following logical operators are supported:
            
              - `or`
            
              - `and`
            
              For details and examples, see the [Using multiple sources of information](/docs/search-single-queries#using-multiple-sources-of-information) section.
            
            
              **Default**: `or`.
            
        
        conversation_option : typing.Optional[ConversationOptionAnyToVideo]
        
        page_limit : typing.Optional[int]
            The number of items to return on each page. When grouping by video, this parameter represents the number of videos per page. Otherwise, it represents the maximum number of video clips per page.
            
            **Max**: `50`.
            
        
        filter : typing.Optional[str]
            This parameter accepts a stringified object to filter search results:
            - For string fields: Use the exact match operator (`=`) to return results that exactly equal the specified value. Syntax: `"field": "value"`.
            - For numeric fields: Use either exact match (`=`) or comparison operators (`gte`, `lte`) for arithmetic comparisons Syntax: `"field": number` or `"field": { "gte": number, "lte": number }`.
            
            The filter object can contain the following properties:
            - `id`: An array of strings to filter by specific video IDs. Example: `"id": ["video1", "video2"]`.
            - `duration`: An object to filter your search results based on the duration of the video containing the segment that matches your query. Example: `"duration": { "gte": 600, "lte": 800 }`.
            - `width`: A numeric value to filter by video width. Example: `"width": 1920` or `"width": { "gte": 1280, "lte": 1920 }`
            - `height`: A numeric value to filter by video height. Example: `"height": 1080` or `"height": { "gte": 720, "lte": 1080 }`.
            - `size`: A numeric value to filter by video size in bytes. Example: `"size": 1048576` or `"size": { "gte": 1048576, "lte": 5242880 }`.
            - `title`: A string value to filter by video title. Example: `"title": "Animal Encounters part 1"`.
            
            To enable filtering by custom fields:
            1. Add metadata to your video by calling the the [`PUT`](/reference/update-video-information) method of the `/indexes/:index-id/videos/:video-id` endpoint
            2. Use the custom fields as filter criteria in your queries. For example, to return only videos where a custom field named `needsReview` of type boolean is `true`, use: `"needs_review": true`.
            
            For more details and examples, see the [Filter search results based on metadata](/docs/filtering-search-results) page.
            
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AnyToVideoSearchAnyToVideoSearchResponse
            Successfully performed a search request.
        
        Examples
        --------
        from twelvelabs import TwelveLabs
        
        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.any_to_video_search.any_to_video_search(
            index_id="index_id",
            search_options=["visual"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "search-v2",
            method="POST",
            data={
                "query_media_type": query_media_type,
                "query_media_url": query_media_url,
                "query_text": query_text,
                "index_id": index_id,
                "search_options": search_options,
                "adjust_confidence_level": adjust_confidence_level,
                "group_by": group_by,
                "threshold": threshold,
                "sort_option": sort_option,
                "operator": operator,
                "conversation_option": conversation_option,
                "page_limit": page_limit,
                "filter": filter,
            },
            files={
                "query_media_file": query_media_file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnyToVideoSearchAnyToVideoSearchResponse,
                    parse_obj_as(
                        type_=AnyToVideoSearchAnyToVideoSearchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def any_to_video_retrieve_specific_page(
        self,
        page_token: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse:
        """
        Use this endpoint to retrieve a specific page of search results.

        **NOTE**: When you use pagination, you will not be charged for retrieving subsequent pages of results.

        Parameters
        ----------
        page_token : str
            A token that identifies the page to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse
            Successfully retrieved the specified page of search results.

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.any_to_video_search.any_to_video_retrieve_specific_page(
            page_token="page-token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"search-v2/{jsonable_encoder(page_token)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse,
                    parse_obj_as(
                        type_=AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAnyToVideoSearchClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def any_to_video_search(
        self,
        *,
        index_id: str,
        search_options: typing.List[
            AnyToVideoSearchAnyToVideoSearchRequestSearchOptionsItem
        ],
        query_media_type: typing.Optional[typing.Literal["image"]] = OMIT,
        query_media_url: typing.Optional[str] = OMIT,
        query_media_file: typing.Optional[core.File] = OMIT,
        query_text: typing.Optional[str] = OMIT,
        adjust_confidence_level: typing.Optional[float] = OMIT,
        group_by: typing.Optional[
            AnyToVideoSearchAnyToVideoSearchRequestGroupBy
        ] = OMIT,
        threshold: typing.Optional[ThresholdSearch] = OMIT,
        sort_option: typing.Optional[
            AnyToVideoSearchAnyToVideoSearchRequestSortOption
        ] = OMIT,
        operator: typing.Optional[str] = OMIT,
        conversation_option: typing.Optional[ConversationOptionAnyToVideo] = OMIT,
        page_limit: typing.Optional[int] = OMIT,
        filter: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnyToVideoSearchAnyToVideoSearchResponse:
        """
        Use this endpoint to search for relevant matches in an index using text or various media formats.
        
        To perform a search using a text query:
        
        - Use the `query_text` parameter to specify your query.
        
        To perform a search using a media query:
        
        - Set the `query_media_type` parameter to the corresponding media type (example: `image`).
        - Specify either one of the following parameters:
          - The `query_media_url` parameter with the publicly accessible URL of your media file.
          - The `query_media_file` parameter with a local media file.
            If both `query_media_url` and `query_media_file` are specified in the same request, `query_media_url` takes precedence.
        
        Before using a media file as a query, ensure that the file meets the [prerequisites](/docs/single-queries-prerequisites).
        
        **NOTE**: This endpoint is rate-limited. For details, see the [Rate limits](/docs/rate-limits) page.
        
        Parameters
        ----------
        index_id : str
            The unique identifier of the index to search.
            
        
        search_options : typing.List[AnyToVideoSearchAnyToVideoSearchRequestSearchOptionsItem]
            Specifies the [sources of information](/docs/search-options) the platform uses when performing a search. You must include the `search_options` parameter separately for each desired source of information.
            
            **NOTES:**
            - The search options you specify must be a subset of the [engine options](/docs/engine-options) used when you created the index.
            - You can specify multiple search options in conjunction with the `operator` parameter described below to broaden or narrow your search.
            
            Example:
            To search using both visual and audio cues, include this parameter twice in the request as shown below:
            ```JSON
            --form search_options=visual \
            --form search_options=conversation \
            ```
            
        
        query_media_type : typing.Optional[typing.Literal["image"]]
            The type of media you wish to use. This parameter is required for media queries. For example, to perform an image-based search, set this parameter to `image`.
            
        
        query_media_url : typing.Optional[str]
            The publicly accessible URL of the media file you wish to use. This parameter is required for media queries if `query_media_file` is not provided.
            
        
        query_media_file : typing.Optional[core.File]
            See core.File for more documentation
        
        query_text : typing.Optional[str]
            The text query to search for. This parameter is required for text queries. Note that the platform supports full natural language-based search.
            
        
        adjust_confidence_level : typing.Optional[float]
            This parameter specifies the strictness of the thresholds for assigning the high, medium, or low confidence levels to search results. If you use a lower value, the thresholds become more relaxed, and more search results will be classified as having high, medium, or low confidence levels. You can use this parameter to include a broader range of potentially relevant video clips, even if some results might be less precise.
            
            **Min**: 0
            **Max**: 1
            **Default:** 0.5
            
        
        group_by : typing.Optional[AnyToVideoSearchAnyToVideoSearchRequestGroupBy]
            Use this parameter to group or ungroup items in a response. It can take one of the following values:
            - `video`:  The platform will group the matching video clips in the response by video.
            - `clip`: The matching video clips in the response will not be grouped.
            
            **Default:** `clip`
            
        
        threshold : typing.Optional[ThresholdSearch]
        
        sort_option : typing.Optional[AnyToVideoSearchAnyToVideoSearchRequestSortOption]
            Use this parameter to specify the sort order for the response.
            
            When performing a search, the platform determines the level of confidence that each video clip matches your search terms. By default, the search results are sorted on the level of confidence in descending order.
            
            If you set this parameter to `score` and `group_by` is set to `video`, the platform will determine the maximum value of the `score` field for each video and sort the videos in the response by the maximum value of this field. For each video, the matching video clips will be sorted by the level of confidence.
            
            If you set this parameter to `clip_count` and `group_by` is set to `video`, the platform will sort the videos in the response by the number of clips. For each video, the matching video clips will be sorted by the level of confidence. You can use `clip_count` only when the matching video clips are sorted by video.
            
            
            **Default:** `score`
            
        
        operator : typing.Optional[str]
            When you perform a search specifying multiple [sources of information](/docs/search-options), you can use the this parameter to broaden or narrow your search.
            
              The following logical operators are supported:
            
              - `or`
            
              - `and`
            
              For details and examples, see the [Using multiple sources of information](/docs/search-single-queries#using-multiple-sources-of-information) section.
            
            
              **Default**: `or`.
            
        
        conversation_option : typing.Optional[ConversationOptionAnyToVideo]
        
        page_limit : typing.Optional[int]
            The number of items to return on each page. When grouping by video, this parameter represents the number of videos per page. Otherwise, it represents the maximum number of video clips per page.
            
            **Max**: `50`.
            
        
        filter : typing.Optional[str]
            This parameter accepts a stringified object to filter search results:
            - For string fields: Use the exact match operator (`=`) to return results that exactly equal the specified value. Syntax: `"field": "value"`.
            - For numeric fields: Use either exact match (`=`) or comparison operators (`gte`, `lte`) for arithmetic comparisons Syntax: `"field": number` or `"field": { "gte": number, "lte": number }`.
            
            The filter object can contain the following properties:
            - `id`: An array of strings to filter by specific video IDs. Example: `"id": ["video1", "video2"]`.
            - `duration`: An object to filter your search results based on the duration of the video containing the segment that matches your query. Example: `"duration": { "gte": 600, "lte": 800 }`.
            - `width`: A numeric value to filter by video width. Example: `"width": 1920` or `"width": { "gte": 1280, "lte": 1920 }`
            - `height`: A numeric value to filter by video height. Example: `"height": 1080` or `"height": { "gte": 720, "lte": 1080 }`.
            - `size`: A numeric value to filter by video size in bytes. Example: `"size": 1048576` or `"size": { "gte": 1048576, "lte": 5242880 }`.
            - `title`: A string value to filter by video title. Example: `"title": "Animal Encounters part 1"`.
            
            To enable filtering by custom fields:
            1. Add metadata to your video by calling the the [`PUT`](/reference/update-video-information) method of the `/indexes/:index-id/videos/:video-id` endpoint
            2. Use the custom fields as filter criteria in your queries. For example, to return only videos where a custom field named `needsReview` of type boolean is `true`, use: `"needs_review": true`.
            
            For more details and examples, see the [Filter search results based on metadata](/docs/filtering-search-results) page.
            
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AnyToVideoSearchAnyToVideoSearchResponse
            Successfully performed a search request.
        
        Examples
        --------
        import asyncio
        
        from twelvelabs import AsyncTwelveLabs
        
        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )
        
        
        async def main() -> None:
            await client.any_to_video_search.any_to_video_search(
                index_id="index_id",
                search_options=["visual"],
            )
        
        
        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search-v2",
            method="POST",
            data={
                "query_media_type": query_media_type,
                "query_media_url": query_media_url,
                "query_text": query_text,
                "index_id": index_id,
                "search_options": search_options,
                "adjust_confidence_level": adjust_confidence_level,
                "group_by": group_by,
                "threshold": threshold,
                "sort_option": sort_option,
                "operator": operator,
                "conversation_option": conversation_option,
                "page_limit": page_limit,
                "filter": filter,
            },
            files={
                "query_media_file": query_media_file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnyToVideoSearchAnyToVideoSearchResponse,
                    parse_obj_as(
                        type_=AnyToVideoSearchAnyToVideoSearchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def any_to_video_retrieve_specific_page(
        self,
        page_token: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse:
        """
        Use this endpoint to retrieve a specific page of search results.

        **NOTE**: When you use pagination, you will not be charged for retrieving subsequent pages of results.

        Parameters
        ----------
        page_token : str
            A token that identifies the page to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse
            Successfully retrieved the specified page of search results.

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.any_to_video_search.any_to_video_retrieve_specific_page(
                page_token="page-token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"search-v2/{jsonable_encoder(page_token)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse,
                    parse_obj_as(
                        type_=AnyToVideoSearchAnyToVideoRetrieveSpecificPageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
