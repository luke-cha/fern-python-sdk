# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.video_indexing_task_list_response import VideoIndexingTaskListResponse
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .. import core
from .types.video_indexing_task_create_response import VideoIndexingTaskCreateResponse
from .types.video_indexing_task_retrieve_response import (
    VideoIndexingTaskRetrieveResponse,
)
from ..core.jsonable_encoder import jsonable_encoder
from .types.video_indexing_task_get_by_status_response import (
    VideoIndexingTaskGetByStatusResponse,
)
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class VideoIndexingTaskClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page: typing.Optional[int] = None,
        page_limit: typing.Optional[int] = None,
        sort_by: typing.Optional[str] = None,
        sort_option: typing.Optional[str] = None,
        id: typing.Optional[str] = None,
        index_id: typing.Optional[str] = None,
        filename: typing.Optional[str] = None,
        duration: typing.Optional[float] = None,
        width: typing.Optional[int] = None,
        height: typing.Optional[int] = None,
        created_at: typing.Optional[str] = None,
        updated_at: typing.Optional[str] = None,
        estimated_time: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VideoIndexingTaskListResponse:
        """
        This method returns a list of the video indexing tasks in your account. The API returns your video indexing tasks sorted by creation date, with the newest at the top of the list.

        Parameters
        ----------
        page : typing.Optional[int]
            A number that identifies the page to retrieve.

            **Default**: `1`.

        page_limit : typing.Optional[int]
            The number of items to return on each page.

            **Default**: `10`.
            **Max**: `50`.

        sort_by : typing.Optional[str]
            The field to sort on. The following options are available:

            - `updated_at`: Sorts by the time, in the <a href="https://datatracker.ietf.org/doc/html/rfc3339" target="_blank">RFC 3339</a> format ("YYYY-MM-DDTHH:mm:ssZ"), when the item was updated.
            - `created_at`: Sorts by the time, in the <a href="https://datatracker.ietf.org/doc/html/rfc3339" target="_blank">RFC 3339</a> format ("YYYY-MM-DDTHH:mm:ssZ"), when the item was created.

            **Default**: `created_at`.

        sort_option : typing.Optional[str]
            The sorting direction. The following options are available:

            - `asc`
            - `desc`

            **Default**: `desc`.

        id : typing.Optional[str]
            Filter by the unique identifier of a video indexing task.

        index_id : typing.Optional[str]
            Filter by the unique identifier of an index.

        filename : typing.Optional[str]
            Filter by filename.

        duration : typing.Optional[float]
            Filter by duration. Expressed in seconds.

        width : typing.Optional[int]
            Filter by width.

        height : typing.Optional[int]
            Filter by height.

        created_at : typing.Optional[str]
            Filter video indexing tasks by the creation date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks that were created on the specified date at or after the given time.

        updated_at : typing.Optional[str]
            Filter video indexing tasks by the last update date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks that were updated on the specified date at or after the given time.

        estimated_time : typing.Optional[str]
            Filter video indexing tasks by the estimated completion date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks estimated to be completed on the specified date at or after the given time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskListResponse
            The video indexing tasks have successfully been retrieved.

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "page": page,
                "page_limit": page_limit,
                "sort_by": sort_by,
                "sort_option": sort_option,
                "_id": id,
                "index_id": index_id,
                "filename": filename,
                "duration": duration,
                "width": width,
                "height": height,
                "created_at": created_at,
                "updated_at": updated_at,
                "estimated_time": estimated_time,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskListResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        index_id: str,
        provide_transcription: typing.Optional[bool] = OMIT,
        language: typing.Optional[str] = OMIT,
        video_file: typing.Optional[core.File] = OMIT,
        transcription_file: typing.Optional[core.File] = OMIT,
        video_url: typing.Optional[str] = OMIT,
        transcription_url: typing.Optional[str] = OMIT,
        disable_video_stream: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VideoIndexingTaskCreateResponse:
        """
        Use this method to create a new video indexing task that uploads and indexes a video. The video you wish to upload must meet the requirements in the [Prerequisites](/docs/upload-single-videos#prerequisites) section of the **Upload single videos** page.
        Note the following about creating a new video indexing task:

        - To upload a file that resides on the local file system, pass the `video_file` parameter. It must be a stream of bytes encoded as `multipart/form-data`.
        - To upload a file from a publicly accessible URL, pass the `video_url` parameter with the URL of your video. It must be a `string`.
        - You must specify at least one of the `video_file` and `video_url` parameters. If you specify both the `video_url` and `video_file` parameters in the same request, the `video_url` parameter takes precedence over `video_file`.
        - To provide a transcription file, you must set the `provide_transcription` parameter to `true` and specify at least one of the `transcription_file` and `transcription_url` parameters:
          - Use the `transcription_file` parameter to provide a transcription from the local file system. It must be a stream of bytes encoded as `multipart/form-data`.
          - Use the `transcription_url` parameter to provide a transcription file from a publicly accessible URL. It must be a `string`.

        **NOTES**:

        - The platform supports uploading video files that can play without additional user interaction or custom video players. Ensure your URL points to the raw video file, not a web page containing the video. Links to third-party hosting sites, cloud storage services, or videos requiring extra steps to play are not supported.
        - This endpoint is rate-limited. For details, see the [Rate limits](/docs/rate-limits) page.

        Parameters
        ----------
        index_id : str
            The unique identifier of the index to which the video is being uploaded.


        provide_transcription : typing.Optional[bool]
            A boolean value specifying whether or not you provide a transcription for this video.


        language : typing.Optional[str]
            Must be set to `en`.

        video_file : typing.Optional[core.File]
            See core.File for more documentation

        transcription_file : typing.Optional[core.File]
            See core.File for more documentation

        video_url : typing.Optional[str]
            Specify this parameter to upload a video from a publicly accessible URL.


        transcription_url : typing.Optional[str]
            When the `provide_transcription` parameter is set to `true`, and you want to provide a transcription from a publicly accessible URL, use the `transcription_url` parameter to specify the URL of your transcription. The transcription must be in the SRT or VTT format.


        disable_video_stream : typing.Optional[bool]
            This parameter indicates if the platform stores the video for streaming. When set to `false`, the platform stores the video, and you can retrieve its URL by calling the [`GET`](/reference/retrieve-video-information) method of the `/indexes/{index-id}/videos/{video-id}` endpoint. You can then use this URL to access the stream over the <a href="https://en.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank">HLS</a> protocol.

            **Default:** `false`


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskCreateResponse
            A video indexing task has successfully been created.

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.create(
            index_id="index_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            data={
                "index_id": index_id,
                "provide_transcription": provide_transcription,
                "language": language,
                "video_url": video_url,
                "transcription_url": transcription_url,
                "disable_video_stream": disable_video_stream,
            },
            files={
                "video_file": video_file,
                "transcription_file": transcription_file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskCreateResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def retrieve(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> VideoIndexingTaskRetrieveResponse:
        """
        This method retrieves a video indexing task.

        Parameters
        ----------
        task_id : str
            The unique identifier of the video indexing task to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskRetrieveResponse
            The specified video indexing task has successfully been retrieved.

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.retrieve(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskRetrieveResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskRetrieveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        This action cannot be undone.
        Note the following about deleting a video indexing task:

        - You can only delete video indexing tasks for which the status is `ready` or `failed`.
        - If the status of your video indexing task is `ready`, you must first delete the video vector associated with your video indexing task by calling the [`DELETE`](/reference/delete-video-information) method of the `/indexes/videos` endpoint.

        Parameters
        ----------
        task_id : str
            The unique identifier of the video indexing task you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.delete(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_by_status(
        self, *, index_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> VideoIndexingTaskGetByStatusResponse:
        """
        This method retrieves the number video indexing tasks in each status for the specified index.

        Parameters
        ----------
        index_id : str
            The unique identifier of the index for which you want to retrieve the number video indexing tasks in each status.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskGetByStatusResponse
            An object containing the number video indexing tasks in each status.


        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.get_by_status(
            index_id="index_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks/status",
            method="GET",
            params={
                "index_id": index_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskGetByStatusResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskGetByStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cloud_to_cloud_transfer(
        self,
        *,
        file: typing.Optional[core.File] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        This method makes a cloud-to-cloud transfer. The videos you wish to upload must meet the requirements in the [Prerequisites](/docs/upload-single-videos#prerequisites) section of the **Upload single videos** page.

        Parameters
        ----------
        file : typing.Optional[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from twelvelabs import TwelveLabs

        client = TwelveLabs(
            api_key="YOUR_API_KEY",
        )
        client.video_indexing_task.cloud_to_cloud_transfer()
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks/transfers",
            method="POST",
            data={},
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncVideoIndexingTaskClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page: typing.Optional[int] = None,
        page_limit: typing.Optional[int] = None,
        sort_by: typing.Optional[str] = None,
        sort_option: typing.Optional[str] = None,
        id: typing.Optional[str] = None,
        index_id: typing.Optional[str] = None,
        filename: typing.Optional[str] = None,
        duration: typing.Optional[float] = None,
        width: typing.Optional[int] = None,
        height: typing.Optional[int] = None,
        created_at: typing.Optional[str] = None,
        updated_at: typing.Optional[str] = None,
        estimated_time: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VideoIndexingTaskListResponse:
        """
        This method returns a list of the video indexing tasks in your account. The API returns your video indexing tasks sorted by creation date, with the newest at the top of the list.

        Parameters
        ----------
        page : typing.Optional[int]
            A number that identifies the page to retrieve.

            **Default**: `1`.

        page_limit : typing.Optional[int]
            The number of items to return on each page.

            **Default**: `10`.
            **Max**: `50`.

        sort_by : typing.Optional[str]
            The field to sort on. The following options are available:

            - `updated_at`: Sorts by the time, in the <a href="https://datatracker.ietf.org/doc/html/rfc3339" target="_blank">RFC 3339</a> format ("YYYY-MM-DDTHH:mm:ssZ"), when the item was updated.
            - `created_at`: Sorts by the time, in the <a href="https://datatracker.ietf.org/doc/html/rfc3339" target="_blank">RFC 3339</a> format ("YYYY-MM-DDTHH:mm:ssZ"), when the item was created.

            **Default**: `created_at`.

        sort_option : typing.Optional[str]
            The sorting direction. The following options are available:

            - `asc`
            - `desc`

            **Default**: `desc`.

        id : typing.Optional[str]
            Filter by the unique identifier of a video indexing task.

        index_id : typing.Optional[str]
            Filter by the unique identifier of an index.

        filename : typing.Optional[str]
            Filter by filename.

        duration : typing.Optional[float]
            Filter by duration. Expressed in seconds.

        width : typing.Optional[int]
            Filter by width.

        height : typing.Optional[int]
            Filter by height.

        created_at : typing.Optional[str]
            Filter video indexing tasks by the creation date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks that were created on the specified date at or after the given time.

        updated_at : typing.Optional[str]
            Filter video indexing tasks by the last update date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks that were updated on the specified date at or after the given time.

        estimated_time : typing.Optional[str]
            Filter video indexing tasks by the estimated completion date and time, in the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format ("YYYY-MM-DDTHH:mm:ssZ"). The platform returns the video indexing tasks estimated to be completed on the specified date at or after the given time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskListResponse
            The video indexing tasks have successfully been retrieved.

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "page": page,
                "page_limit": page_limit,
                "sort_by": sort_by,
                "sort_option": sort_option,
                "_id": id,
                "index_id": index_id,
                "filename": filename,
                "duration": duration,
                "width": width,
                "height": height,
                "created_at": created_at,
                "updated_at": updated_at,
                "estimated_time": estimated_time,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskListResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        index_id: str,
        provide_transcription: typing.Optional[bool] = OMIT,
        language: typing.Optional[str] = OMIT,
        video_file: typing.Optional[core.File] = OMIT,
        transcription_file: typing.Optional[core.File] = OMIT,
        video_url: typing.Optional[str] = OMIT,
        transcription_url: typing.Optional[str] = OMIT,
        disable_video_stream: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VideoIndexingTaskCreateResponse:
        """
        Use this method to create a new video indexing task that uploads and indexes a video. The video you wish to upload must meet the requirements in the [Prerequisites](/docs/upload-single-videos#prerequisites) section of the **Upload single videos** page.
        Note the following about creating a new video indexing task:

        - To upload a file that resides on the local file system, pass the `video_file` parameter. It must be a stream of bytes encoded as `multipart/form-data`.
        - To upload a file from a publicly accessible URL, pass the `video_url` parameter with the URL of your video. It must be a `string`.
        - You must specify at least one of the `video_file` and `video_url` parameters. If you specify both the `video_url` and `video_file` parameters in the same request, the `video_url` parameter takes precedence over `video_file`.
        - To provide a transcription file, you must set the `provide_transcription` parameter to `true` and specify at least one of the `transcription_file` and `transcription_url` parameters:
          - Use the `transcription_file` parameter to provide a transcription from the local file system. It must be a stream of bytes encoded as `multipart/form-data`.
          - Use the `transcription_url` parameter to provide a transcription file from a publicly accessible URL. It must be a `string`.

        **NOTES**:

        - The platform supports uploading video files that can play without additional user interaction or custom video players. Ensure your URL points to the raw video file, not a web page containing the video. Links to third-party hosting sites, cloud storage services, or videos requiring extra steps to play are not supported.
        - This endpoint is rate-limited. For details, see the [Rate limits](/docs/rate-limits) page.

        Parameters
        ----------
        index_id : str
            The unique identifier of the index to which the video is being uploaded.


        provide_transcription : typing.Optional[bool]
            A boolean value specifying whether or not you provide a transcription for this video.


        language : typing.Optional[str]
            Must be set to `en`.

        video_file : typing.Optional[core.File]
            See core.File for more documentation

        transcription_file : typing.Optional[core.File]
            See core.File for more documentation

        video_url : typing.Optional[str]
            Specify this parameter to upload a video from a publicly accessible URL.


        transcription_url : typing.Optional[str]
            When the `provide_transcription` parameter is set to `true`, and you want to provide a transcription from a publicly accessible URL, use the `transcription_url` parameter to specify the URL of your transcription. The transcription must be in the SRT or VTT format.


        disable_video_stream : typing.Optional[bool]
            This parameter indicates if the platform stores the video for streaming. When set to `false`, the platform stores the video, and you can retrieve its URL by calling the [`GET`](/reference/retrieve-video-information) method of the `/indexes/{index-id}/videos/{video-id}` endpoint. You can then use this URL to access the stream over the <a href="https://en.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank">HLS</a> protocol.

            **Default:** `false`


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskCreateResponse
            A video indexing task has successfully been created.

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.create(
                index_id="index_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            data={
                "index_id": index_id,
                "provide_transcription": provide_transcription,
                "language": language,
                "video_url": video_url,
                "transcription_url": transcription_url,
                "disable_video_stream": disable_video_stream,
            },
            files={
                "video_file": video_file,
                "transcription_file": transcription_file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskCreateResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def retrieve(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> VideoIndexingTaskRetrieveResponse:
        """
        This method retrieves a video indexing task.

        Parameters
        ----------
        task_id : str
            The unique identifier of the video indexing task to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskRetrieveResponse
            The specified video indexing task has successfully been retrieved.

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.retrieve(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskRetrieveResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskRetrieveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        This action cannot be undone.
        Note the following about deleting a video indexing task:

        - You can only delete video indexing tasks for which the status is `ready` or `failed`.
        - If the status of your video indexing task is `ready`, you must first delete the video vector associated with your video indexing task by calling the [`DELETE`](/reference/delete-video-information) method of the `/indexes/videos` endpoint.

        Parameters
        ----------
        task_id : str
            The unique identifier of the video indexing task you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.delete(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_by_status(
        self, *, index_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> VideoIndexingTaskGetByStatusResponse:
        """
        This method retrieves the number video indexing tasks in each status for the specified index.

        Parameters
        ----------
        index_id : str
            The unique identifier of the index for which you want to retrieve the number video indexing tasks in each status.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VideoIndexingTaskGetByStatusResponse
            An object containing the number video indexing tasks in each status.


        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.get_by_status(
                index_id="index_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks/status",
            method="GET",
            params={
                "index_id": index_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VideoIndexingTaskGetByStatusResponse,
                    parse_obj_as(
                        type_=VideoIndexingTaskGetByStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cloud_to_cloud_transfer(
        self,
        *,
        file: typing.Optional[core.File] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        This method makes a cloud-to-cloud transfer. The videos you wish to upload must meet the requirements in the [Prerequisites](/docs/upload-single-videos#prerequisites) section of the **Upload single videos** page.

        Parameters
        ----------
        file : typing.Optional[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from twelvelabs import AsyncTwelveLabs

        client = AsyncTwelveLabs(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.video_indexing_task.cloud_to_cloud_transfer()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks/transfers",
            method="POST",
            data={},
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
